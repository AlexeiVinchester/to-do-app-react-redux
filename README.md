1. Создаем actions/index.js 

    В нем добавляем функции-генераторы для всех actions, которые могут быть: 
        - добавить дело в список
        - нажать на дело в списке (по нажатию менять статус дела с активного на неактивный и наоборот)
        - установить фильтр на отображение списка дел
    
    Каждая из функций возвращает объект-action
    Данные функции генераторы мы будем передавать в dispatch().

    Могут быть три вида фильтров:
        - показывать все
        - показывать завершенные (completed)
        - показывать активные (ective)

    Позде в зависимости от установленного фильтра будем осуществлять фильтрацию массива и возвращать отфильтрованный массив

2. Создаем reducers

    Определим шаблон состояния. Это будет объект с двумя свойствами: todos - array, filter - string;
    Каждый элемент массива todos - объект с тремя свойствами: id, completed, text
    В reducer обычно с помощью конструкции switch разделяют case на все actions.

    У нас есть три actions: два из них меняют свойство todos, один - свойство filter.

    Поэтому мы создадим два reducer, а затем сделает комбинацию reducers с помощью combineReducers()

3. Создаем презентационный компонент ToDo

    Данный компонент отображает одну задачу из списка

    Так же сделаем обработку типов пропсов

4. Создаем презентационный компонент ToDoList

    Данный компонент отображает список всех дел, которые у нас есть. При этом он пробрасывает каждому дочернему ToDo функцию-колбэк, которая потом должна срабатывать при нажатии на задачу. Здесь мы и передадим этой функции id задачи, чтобы понимать, какую задачу переводить из статуса active в статус completed

    Так же сделаем обработку типов пропсов

5. Создаем презентационный компонент Link

    Каждый из этих компонент будет возвращать кнопку для выбора фильтрации в дальнейшем. При нажатии на кнопку мы будем запускать dispatch(), которому будем передавать action для изменения статуса таска

    Так же сделаем обработку типов пропсов

6. Создаем компонент-контейнер VisibleToDoList

    Данный компонент будет оберткой для компонента ToDoList, которому нужно передать два пропса - данные и функцию. Данные будем получать в функции mapStateToProps, функцию - mapDispatchToProp. А далее уже передадим их в функцию connect(), которая вернет функцию, ей мы передадим компонент ToDoList и получим компонент-обертку высшего порядка VisibleToDoList.

7. Создаем копмонент-контейнер FilterLink

    Данный компонент будет оберткой для компонента Link, которому нужно передать два пропса: active - bool, onClick - функцию, в которой потом будем вызывать dispatch для установки фильтра по нажатию кнопки. Данные будем получать в функции mapStateToProps, функцию - mapDispatchToProp. А далее уже передадим их в функцию connect(). 

8. Теперь добавим компонент Footer

    В нем будет три кнопки для осуществления фильтрации. По нажатию на кнопку будет фильтроваться список отображаемых задач. За кнопки у нас отвечает Link - компонент представления. Мы его оборачиваем в компонент-контейнер FilterLink. Каждому из них передает в качестве пропса filter строку для определения фильтрации. А затем Link берет это свойство из ownProps.

9. Добавим компонент контейнер AddToDo

    Это компонент-контейнер, ибо ему нужно иметь доступ в методу dispatch(), чтобы по нажатию на кнопку добавить новый такс в стор. Ref в input принимает функцию, которая в качестве параметра принимает сам input и присваивает ее переменной input, и запускает эту функцию после монтирования компонента. Конечно, можно было добавить в тег input проп onChange и хранить введенное значение в состоянии, но тогда при каждом введенном символе состояние бы обновлялось и были бы постоянные рендеры, а здесь мы избегаем этого.
    В конце с помощью метода connect() связываем стор и компонент и возвращаем обертку. 